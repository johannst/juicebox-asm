searchState.loadedDescShard("juicebox_asm", 0, "A simple <code>x64</code> jit assembler with a minimal runtime to …\n<code>x64</code> jit assembler.\nType representing a 16 bit immediate.\nType representing a 32 bit immediate.\nType representing a 64 bit immediate.\nType representing an 8 bit immediate.\nA label which is used as target for jump instructions.\nA memory operand with <code>word</code> size (16 bit).\nA memory operand with <code>dword</code> size (32 bit).\nA memory operand with <code>qword</code> size (64 bit).\nA memory operand with <code>byte</code> size (8 bit).\nDefinition of 16 bit registers.\nDefinition of 32 bit registers.\nDefinition of 64 bit registers.\nDefinition of 8 bit registers.\nA simple <code>mmap</code>ed runtime with executable pages.\nAdd the block of <code>code</code> to the runtime and a get function …\nBind the Label to the current location.\nDisassemble the code currently added to the runtime, using …\nDisassemble the code currently added to the runtime, using …\nUnmaps the code page. This invalidates all the function …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a memory operand with <code>indirect</code> addressing mode. For …\nCreate a memory operand with <code>indirect</code> addressing mode. For …\nCreate a memory operand with <code>indirect</code> addressing mode. For …\nCreate a memory operand with <code>indirect</code> addressing mode. For …\nCreate a memory operand with <code>base + index</code> addressing mode. …\nCreate a memory operand with <code>base + index</code> addressing mode. …\nCreate a memory operand with <code>base + index</code> addressing mode. …\nCreate a memory operand with <code>base + index</code> addressing mode. …\nCreate a memory operand with <code>indirect + displacement</code> …\nCreate a memory operand with <code>indirect + displacement</code> …\nCreate a memory operand with <code>indirect + displacement</code> …\nCreate a memory operand with <code>indirect + displacement</code> …\nTrait definitions of various instructions.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsume the assembler and get the emitted code.\nCreate a new <code>x64</code> jit assembler.\nCreate a new <code>unbound</code> Label.\nCreate a new Runtime.\nEmit a <code>nop</code> instruction.\nEmit a <code>ret</code> instruction.\nCreate a new Runtime which also generates static perf …\nTrait for <code>add</code> instruction kinds.\nTrait for <code>call</code> instruction kinds.\nTrait for <code>cmovnz</code> instruction kinds.\nTrait for <code>cmovz</code> instruction kinds.\nTrait for <code>cmp</code> instruction kinds.\nTrait for <code>dec</code> instruction kinds.\nTrait for <code>inc</code> instruction kinds.\nTrait for <code>jmp</code> instruction kinds.\nTrait for <code>jnz</code> instruction kinds.\nTrait for <code>jz</code> instruction kinds.\nTrait for <code>mov</code> instruction kinds.\nTrait for <code>pop</code> instruction kinds.\nTrait for <code>push</code> instruction kinds.\nTrait for <code>sub</code> instruction kinds.\nTrait for <code>test</code> instruction kinds.\nTrait for <code>xor</code> instruction kinds.\nEmit an add instruction.\nEmit a call instruction.\nEmit a (conditional) move if not zero instruction.\nEmit a (conditional) move if zero instruction.\nEmit a compare instruction.\nEmit a decrement instruction.\nEmit a increment instruction.\nEmit an unconditional jump instruction.\nEmit a conditional jump if not zero instruction (<code>ZF = 0</code>).\nEmit a conditional jump if zero instruction (<code>ZF = 1</code>).\nEmit an move instruction.\nEmit a pop instruction.\nEmit a push instruction.\nEmit an sub instruction.\nEmit a logical compare instruction.\nEmit a xor instruction.")