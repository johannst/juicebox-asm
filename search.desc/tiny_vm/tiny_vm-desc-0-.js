searchState.loadedDescShard("tiny_vm", 0, "TinyVm example.\nAdd the register to the register <code>reg1 += reg2</code>.\nAdd the immediate to the register <code>reg += imm</code>.\nJump unconditional (absolute addressing) <code>pc = disp</code>.\nJump if the register is zero (absolute addressing) …\nA minial fixup utility to implement jump labels when …\nHalt the VM.\nLoad a value from the memory (absolute addressing) into …\nLoad the immediate value into the register <code>reg = imm</code>.\nA guest physical address.\nStore a value from the register into the memory (absolute …\nThe instructions for the <code>TinyVm</code>.\nThe registers for the <code>TinyVm</code>.\nThe <code>TinyVm</code> virtual machine state.\nBind the <code>Fixup</code> to the current location of <code>prog</code> and resolve …\nDump the VM state to stdout.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRun in interpreter mode until the next <code>TinyInsn::Halt</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRun in JIT mode until the next <code>TinyInsn::Halt</code> instruction …\nGenerate a guest program to compute the fiibonacci …\nGenerate a simple count down loop to crunch some …\nGenerate a test program for the jit.\nCreate a new <code>TinyVm</code> and initialize the instruction memory …\nCreate a new <code>Fixup</code> at the current pc.\nRead guest data memory.\nRead guest register.\nWrite guest data memory.\nWrite guest register.")